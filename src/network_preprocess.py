"""
Network Preprocessing Module

Provides preprocessing and enhancement functions for road network data
"""
import os
import numpy as np
import networkx as nx
from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)


def enrich_network_info(
    network: nx.DiGraph,
    data_dir: str = 'data'
) -> nx.DiGraph:
    """
    Enrich network information, add adjacency relationships and other necessary network attributes
    
    Add the following attributes to road network graph:
    - link_nodes_dict: Link ID to node pair mapping
    - neighbor_links_O: Downstream adjacent links of link (loaded from file or computed)
    - neighbor_links_D: Upstream adjacent links of link (loaded from file or computed)
    
    Args:
        network: NetworkX directed graph object
        data_dir: data directory path
    
    Returns:
        Enhanced road network graph
    """
    logger.info("Start enriching network information...")
    
    # Build link-node mapping (used for shortest path fallback)
    link_nodes_dict = {}
    
    for node1, node2 in network.edges:
        link_id = network.edges[node1, node2]['EDGEID']
        link_nodes_dict[link_id] = (node1, node2)
    
    # Load precomputed adjacent link information (generated by generate_sample_data.py or provided externally)
    neighbor_links_O_file = os.path.join(data_dir, 'neighbor_links_O.npy')
    neighbor_links_D_file = os.path.join(data_dir, 'neighbor_links_D.npy')
    
    if os.path.exists(neighbor_links_O_file):
        neighbor_links_O = np.load(neighbor_links_O_file, allow_pickle=True).item()
        logger.info(f"Loaded neighbor_links_O successfully, totaling {len(neighbor_links_O)} links")
    else:
        logger.warning(f"Not found {neighbor_links_O_file}, will compute from network")
        # Compute neighbor_links_O if file doesn't exist
        neighbor_links_O = compute_neighbor_links(network)[0]
    
    if os.path.exists(neighbor_links_D_file):
        neighbor_links_D = np.load(neighbor_links_D_file, allow_pickle=True).item()
        logger.info(f"Loaded neighbor_links_D successfully, totaling {len(neighbor_links_D)} links")
    else:
        logger.warning(f"Not found {neighbor_links_D_file}, will compute from network")
        # Compute neighbor_links_D if file doesn't exist
        neighbor_links_D = compute_neighbor_links(network)[1]
    
    # Add information to network graph
    network.graph['link_nodes_dict'] = link_nodes_dict
    network.graph['neighbor_links_O'] = neighbor_links_O
    network.graph['neighbor_links_D'] = neighbor_links_D
    
    logger.info(f"Network contains {len(link_nodes_dict)} links")
    
    logger.info("Network information enrichment completed")
    return network


def compute_neighbor_links(network: nx.DiGraph):
    """
    Compute neighbor links from network structure
    Returns same as generate_sample_data.py's create_neighbor_links function
    
    Args:
        network: NetworkX directed graph
        
    Returns:
        (neighbor_links_O, neighbor_links_D): Downstream and upstream adjacency dictionaries
    """
    from collections import defaultdict
    
    neighbor_links_O = defaultdict(list)
    neighbor_links_D = defaultdict(list)
    
    # Build node-to-link mappings
    node_to_outgoing_links = defaultdict(list)
    node_to_incoming_links = defaultdict(list)
    
    for u, v, data in network.edges(data=True):
        link_id = data['EDGEID']
        node_to_outgoing_links[u].append(link_id)
        node_to_incoming_links[v].append(link_id)
    
    # Build link adjacency relationships
    for u, v, data in network.edges(data=True):
        current_link = data['EDGEID']
        neighbor_links_O[current_link] = node_to_outgoing_links[v]
        neighbor_links_D[current_link] = node_to_incoming_links[u]
    
    return dict(neighbor_links_O), dict(neighbor_links_D)


def construct_twin_network(network: nx.DiGraph) -> nx.DiGraph:
    """
    Construct twin network (for path planning)
    
    In twin network, links of original network become nodesï¼ŒConnection relationships between links become edges
    
    Args:
        network: Original network
    
    Returns:
        Twin network
    """
    neighbor_links_O = network.graph['neighbor_links_O']
    link_nodes_dict = network.graph['link_nodes_dict']
    
    nodelist = []
    for node1, node2 in network.edges:
        nodelist.append(network.edges[node1, node2]['EDGEID'])
    
    edgelist = []
    for o_link in neighbor_links_O:
        for d_link in neighbor_links_O[o_link]:
            node1, node2 = link_nodes_dict[d_link]
            edgelist.append((
                o_link, 
                d_link, 
                {'VLENGTH': network.edges[node1, node2]['VLENGTH']}
            ))
    
    G = nx.DiGraph()
    G.add_nodes_from(nodelist)
    G.add_edges_from(edgelist)
    
    return G


def get_candidate_paths_k_shortest(
    G: nx.DiGraph,
    origin: int,
    destination: int,
    k: int = 10,
    max_path_len: Optional[int] = None
) -> list:
    """
    Get K shortest paths
    
    Args:
        G: Graph object
        origin: Origin
        destination: Destination
        k: Number of paths to return
        max_path_len: Maximum path length limit
    
    Returns:
        List of paths
    """
    paths = []
    try:
        X = nx.shortest_simple_paths(G, origin, destination)
        for counter, path in enumerate(X):
            if max_path_len is None or len(path) <= max_path_len:
                paths.append(path)
            if counter == k - 1:
                break
    except:
        return paths
    
    return paths

